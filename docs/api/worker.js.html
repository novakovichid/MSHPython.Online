<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: worker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: worker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>let pyodide = null;
let pyodideReady = false;
let stdinResolver = null;
const stdinQueue = [];
let stdinShared = null;
let stdinHeader = null;
let stdinBuffer = null;
let stdinMode = "message";
const forceSharedBase =
    typeof self !== "undefined" &amp;&amp;
    self.navigator &amp;&amp;
    (/Safari/i.test(self.navigator.userAgent || "") &amp;&amp; !/Chrome|Chromium|Edg/i.test(self.navigator.userAgent || ""));
if (typeof self !== "undefined") {
    self.force_shared = forceSharedBase;
}
const stdinDecoder = typeof TextDecoder !== "undefined"
    ? new TextDecoder()
    : {
        decode: (input) => {
            const bytes = input instanceof Uint8Array ? input : new Uint8Array(input || []);
            let binary = "";
            const chunk = 0x8000;
            for (let i = 0; i &lt; bytes.length; i += chunk) {
                binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
            }
            return decodeURIComponent(escape(binary));
        }
    };

/**
 * Decodes UTF-8 bytes to string using TextDecoder with fallback.
 * @param {Uint8Array} bytes - The bytes to decode
 * @returns {string} Decoded string
 */
function decodeUtf8Fallback(bytes) {
    let binary = "";
    const chunk = 0x8000;
    for (let i = 0; i &lt; bytes.length; i += chunk) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
    }
    try {
        return decodeURIComponent(escape(binary));
    } catch (error) {
        return binary;
    }
}

function decodeSharedBytes(bytes) {
    try {
        return String(stdinDecoder.decode(bytes));
    } catch (error) {
        return decodeUtf8Fallback(bytes);
    }
}

/**
 * Main message handler for the Web Worker.
 * Handles: stdin responses, turtle events, file requests, runtime init, and code execution.
 * @param {MessageEvent} event - The message event from the main thread
 */
self.onmessage = async (event) => {
    const message = event.data;
    if (message.type === "stdin_response") {
        handleStdinResponse(message);
        return;
    }
    if (message.type === "turtle_event") {
        if (self.turtle_recv) {
            self.turtle_recv(message.event);
        }
        return;
    }
    if (message.type === "get_file") {
        handleGetFile(message);
        return;
    }
    if (message.type === "init") {
        await initializeRuntime(message);
        return;
    }
    if (message.type === "run") {
        await runCode(message);
    }
};

/**
 * Handles stdin response from main thread and resolves pending input promise.
 * @param {Object} message - Message with stdin value
 */
function handleStdinResponse(message) {
    const value = typeof message.value === "string" ? message.value : "";
    if (stdinResolver) {
        const resolve = stdinResolver;
        stdinResolver = null;
        resolve(value);
        return;
    }
    stdinQueue.push(value);
}

function requestStdin() {
    if (stdinQueue.length) {
        return Promise.resolve(stdinQueue.shift());
    }
    return new Promise((resolve) => {
        stdinResolver = resolve;
        postMessage({ type: "stdin_request", mode: "message" });
    });
}

function setupSharedStdin(shared) {
    if (!shared || typeof Atomics === "undefined" || typeof Atomics.wait !== "function") {
        return false;
    }
    try {
        stdinShared = shared;
        stdinHeader = new Int32Array(shared, 0, 2);
        stdinBuffer = new Uint8Array(shared, 8);
    } catch (error) {
        stdinShared = null;
        stdinHeader = null;
        stdinBuffer = null;
        return false;
    }
    stdinMode = "shared";
    const readShared = () => {
        const flag = Atomics.load(stdinHeader, 0);
        if (flag !== 1) {
            return null;
        }
        const length = Atomics.load(stdinHeader, 1);
        const safeLength = Number.isFinite(length) ? Math.max(0, Math.min(length, stdinBuffer.length)) : 0;
        let slice = stdinBuffer.subarray(0, safeLength);
        Atomics.store(stdinHeader, 0, 0);
        Atomics.store(stdinHeader, 1, 0);
        let decoded = decodeSharedBytes(slice);
        if (!decoded &amp;&amp; safeLength > 0) {
            return decodeUtf8Fallback(slice);
        }
        if (!decoded &amp;&amp; safeLength === 0) {
            let fallbackLength = 0;
            while (fallbackLength &lt; stdinBuffer.length &amp;&amp; stdinBuffer[fallbackLength] !== 0) {
                fallbackLength += 1;
            }
            if (fallbackLength > 0) {
                slice = stdinBuffer.subarray(0, fallbackLength);
                decoded = decodeSharedBytes(slice);
            }
        }
        return decoded;
    };
    self.stdin_blocking = () => {
        if (!stdinHeader || !stdinBuffer) {
            return "";
        }
        const ready = readShared();
        if (ready !== null) {
            return ready;
        }
        postMessage({ type: "stdin_request", mode: "shared" });
        Atomics.wait(stdinHeader, 0, 0);
        const next = readShared();
        return next === null ? "" : next;
    };
    return true;
}

/**
 * Initializes Pyodide runtime in worker and configures stdin transport mode.
 * @param {Object} message - Init payload with runtime URLs and shared stdin buffer.
 * @returns {Promise&lt;void>}
 */
async function initializeRuntime(message) {
    self.stdin_blocking = null;
    const sharedReady = setupSharedStdin(message.stdinShared);
    if (typeof self !== "undefined") {
        self.force_shared = forceSharedBase &amp;&amp; sharedReady;
    }
    if (sharedReady) {
        stdinMode = "shared";
    } else {
        stdinMode = "message";
    }
    if (!pyodideReady) {
        const indexURL = message.indexURL;
        importScripts(indexURL + "pyodide.js");
        pyodide = await loadPyodide({
            indexURL
        });

        if (pyodide.setStdout) {
            pyodide.setStdout({
                batched: (text) => postMessage({ type: "stdout", data: text })
            });
        }
        if (pyodide.setStderr) {
            pyodide.setStderr({
                batched: (text) => postMessage({ type: "stderr", data: text })
            });
        }
        self.stdin = requestStdin;
        self.send_stdout = (text) => postMessage({ type: "stdout", data: text });
        self.turtle_send = (payload) => {
            let event = payload;
            if (typeof payload === "string") {
                try {
                    event = JSON.parse(payload);
                } catch (error) {
                    event = { type: "error", message: String(payload) };
                }
            }
            postMessage({ type: "turtle", event });
        };

        await pyodide.runPythonAsync(TURTLE_SHIM);

        pyodideReady = true;
    }

    stdinMode = "message";
    self.stdin_mode = stdinMode;
    self.set_stdin_mode = (mode) => {
        const next = mode === "shared" &amp;&amp; stdinShared ? "shared" : "message";
        if (stdinMode === next) {
            return;
        }
        stdinMode = next;
        self.stdin_mode = stdinMode;
        postMessage({ type: "stdin_mode", mode: stdinMode });
    };
    postMessage({ type: "stdin_mode", mode: stdinMode });
    if (forceSharedBase &amp;&amp; stdinShared) {
        self.set_stdin_mode("shared");
    }
    postMessage({ type: "ready" });
}

/**
 * Runs Python entrypoint in worker FS and streams execution events to main thread.
 * @param {Object} message - Run payload containing files, assets and entrypoint.
 * @returns {Promise&lt;void>}
 */
async function runCode(message) {
    if (!pyodideReady) {
        postMessage({ type: "stderr", data: "Среда выполнения не готова.\n" });
        return;
    }

    postMessage({ type: "status", state: "running" });
    try {
        resetFs();
        writeFiles(message.files);
        writeAssets(message.assets);
        await pyodide.runPythonAsync(buildRunner(message.entry));
        postMessage({ type: "status", state: "done" });
    } catch (error) {
        postMessage({ type: "stderr", data: String(error) + "\n" });
        postMessage({ type: "status", state: "error" });
    }
}

function resetFs() {
    const FS = pyodide.FS;
    if (!FS.analyzePath("/project").exists) {
        FS.mkdir("/project");
    }
    clearDir("/project");
    FS.chdir("/project");
}

function clearDir(path) {
    const FS = pyodide.FS;
    const entries = FS.readdir(path);
    entries.forEach((entry) => {
        if (entry === "." || entry === "..") {
            return;
        }
        const fullPath = path + "/" + entry;
        const stat = FS.stat(fullPath);
        if (FS.isDir(stat.mode)) {
            clearDir(fullPath);
            FS.rmdir(fullPath);
        } else {
            FS.unlink(fullPath);
        }
    });
}

function writeFiles(files) {
    const FS = pyodide.FS;
    files.forEach((file) => {
        const normalized = String(file.content || "")
            .replace(/\r\n?/g, "\n")
            .replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, " ")
            .replace(/[\u200B\u200C\u200D\u2060\uFEFF]/g, "");
        FS.writeFile(`/project/${file.name}`, normalized, { encoding: "utf8" });
    });
}

function writeAssets(assets) {
    const FS = pyodide.FS;
    assets.forEach((asset) => {
        FS.writeFile(`/project/${asset.name}`, asset.data);
    });
}

function handleGetFile(message) {
    if (!pyodideReady || !pyodide) {
        postMessage({ type: "file_data", requestId: message.requestId, error: "Runtime not ready" });
        return;
    }
    try {
        const FS = pyodide.FS;
        const filename = message.filename;
        let path = filename;
        if (!path.startsWith("/project/") &amp;&amp; !path.startsWith("/")) {
            path = `/project/${path}`;
        }
        const pathInfo = FS.analyzePath(path);
        if (pathInfo.exists &amp;&amp; !pathInfo.isRoot) {
            const data = FS.readFile(path, { encoding: "binary" });
            // Преобразуем Uint8Array в ArrayBuffer для передачи через postMessage
            let buffer;
            if (data instanceof Uint8Array) {
                if (data.byteOffset === 0 &amp;&amp; data.byteLength === data.buffer.byteLength) {
                    buffer = data.buffer;
                } else {
                    buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
                }
            } else {
                buffer = data;
            }
            postMessage({
                type: "file_data",
                requestId: message.requestId,
                filename: filename,
                data: buffer,
                mime: message.mime || null
            }, [buffer]);
        } else {
            postMessage({ type: "file_data", requestId: message.requestId, error: "File not found" });
        }
    } catch (error) {
        postMessage({ type: "file_data", requestId: message.requestId, error: String(error) });
    }
}

function buildRunner(entry) {
    const entryLiteral = JSON.stringify(entry);
    return `
import runpy, sys, os, builtins, js
try:
    from pyodide.ffi import run_sync
except Exception:
    run_sync = None

def _input(prompt=""):
    if prompt:
        js.send_stdout(prompt)
    force_shared = bool(getattr(js, "force_shared", False))
    if run_sync and not force_shared:
        try:
            return run_sync(js.stdin())
        except Exception:
            try:
                setter = getattr(js, "set_stdin_mode", None)
                if setter:
                    setter("shared")
            except Exception:
                pass
    blocking = getattr(js, "stdin_blocking", None)
    if blocking:
        try:
            return blocking()
        except Exception:
            pass
    return ""

builtins.input = _input
sys.path.insert(0, os.getcwd())
project_dir = os.getcwd()
project_modules = set()
try:
    for fname in os.listdir(project_dir):
        if fname.endswith(".py"):
            project_modules.add(os.path.splitext(fname)[0])
except Exception:
    project_modules = set()
for name, module in list(sys.modules.items()):
    if name == "__main__":
        continue
    try:
        mod_file = getattr(module, "__file__", "")
    except Exception:
        mod_file = ""
    if mod_file and str(mod_file).startswith(project_dir):
        sys.modules.pop(name, None)
        continue
    if name in project_modules:
        sys.modules.pop(name, None)
try:
    import turtle
    turtle.reset()
except Exception:
    pass
runpy.run_path(${entryLiteral}, run_name="__main__")
`;
}

const TURTLE_SHIM = `
import math
import types
import json
import js
from pyodide.ffi import create_proxy

CANVAS_WIDTH = 400
CANVAS_HEIGHT = 300

def _send(event):
    js.turtle_send(json.dumps(event))

def _emit(event):
    if "screen_state" in globals():
        if screen_state.tracer_n == 0 and event.get("type") not in ("init", "listen"):
            screen_state.pending_events.append(event)
            return
    _send(event)

def _emit_turtle(state):
    _emit({
        "type": "turtle",
        "tid": state.tid,
        "x": state.x,
        "y": state.y,
        "heading": state.heading,
        "visible": state.visible,
        "speed": state.speed_value,
        "mode": state.screen.mode_name,
        "shape": state.shape_name,
        "stretch": [state.stretch_wid, state.stretch_len],
        "pencolor": state.pen_color,
        "fillcolor": state.fill_color,
        "pensize": state.pen_size
    })

def _emit_move(state, x1, y1, x2, y2, pendown):
    _emit({
        "type": "move",
        "tid": state.tid,
        "x1": x1,
        "y1": y1,
        "x2": x2,
        "y2": y2,
        "pen": pendown,
        "color": state.pen_color,
        "width": state.pen_size,
        "heading": state.heading,
        "visible": state.visible,
        "speed": state.speed_value,
        "mode": state.screen.mode_name
    })

def _emit_turn(state):
    _emit({
        "type": "turn",
        "tid": state.tid,
        "x": state.x,
        "y": state.y,
        "heading": state.heading,
        "visible": state.visible,
        "speed": state.speed_value,
        "mode": state.screen.mode_name
    })

def _clamp(value, low, high):
    return max(low, min(high, value))

def _color_to_css(value, colormode):
    if isinstance(value, (tuple, list)) and len(value) >= 3:
        r, g, b = value[0], value[1], value[2]
        if colormode == 1.0:
            r = int(_clamp(r, 0, 1) * 255)
            g = int(_clamp(g, 0, 1) * 255)
            b = int(_clamp(b, 0, 1) * 255)
        else:
            r = int(r)
            g = int(g)
            b = int(b)
        return f"rgb({r}, {g}, {b})"
    return str(value)

def _color_from_args(args):
    if len(args) == 1:
        return args[0]
    if len(args) >= 3:
        return (args[0], args[1], args[2])
    return args[0]

def _parse_position(x, y=None):
    if y is None and isinstance(x, (tuple, list)):
        return x[0], x[1]
    return x, y

def _normalize_button(btn):
    try:
        return int(btn)
    except Exception:
        return 1

def _normalize_key(key):
    if key is None:
        return None
    return str(key)

def _next_turtle_id(screen):
    screen._turtle_id += 1
    return screen._turtle_id

def _set_handler(store, key, fun, add):
    if fun is None:
        if key in store:
            del store[key]
        return
    if add is True:
        store.setdefault(key, []).append(fun)
    else:
        store[key] = [fun]

def _set_any_handler(store, fun, add):
    if fun is None:
        store.clear()
        return
    if add is True:
        store.append(fun)
    else:
        store[:] = [fun]

def _call_handlers(store, key, *args):
    for fun in list(store.get(key, [])):
        try:
            fun(*args)
        except Exception:
            pass

def _call_any(store, *args):
    for fun in list(store):
        try:
            fun(*args)
        except Exception:
            pass

def _font_to_css(font):
    if isinstance(font, (tuple, list)) and len(font) >= 2:
        family = font[0]
        size = font[1]
        style = "normal"
        weight = "normal"
        if len(font) > 2:
            for part in font[2:]:
                if isinstance(part, str):
                    token = part.lower()
                    if "bold" in token:
                        weight = "bold"
                    if "italic" in token:
                        style = "italic"
        return f"{style} {weight} {size}px {family}".strip()
    if font:
        return str(font)
    return "16px Rubik"

class _ScreenState:
    def __init__(self):
        self.bg = "#f5f9ff"
        self.canvas_width = CANVAS_WIDTH
        self.canvas_height = CANVAS_HEIGHT
        self.color_mode = 1.0
        self.mode_name = "standard"
        self.world = None
        self._turtle_id = 0
        self.pending_events = []
        self.listen_enabled = False
        self.key_press_handlers = {}
        self.key_release_handlers = {}
        self.key_any_press = []
        self.key_any_release = []
        self.mouse_click_handlers = {}
        self.mouse_release_handlers = {}
        self.mouse_drag_handlers = {}
        self.turtle_click_handlers = {}
        self.turtle_release_handlers = {}
        self.turtle_drag_handlers = {}
        self.delay_ms = 10
        self.tracer_n = 1
        self.title_text = ""
        self.bg_picture = None
        self.shapes = set(["classic"])
        self._emit_init()

    def _emit_init(self):
        _send({
            "type": "init",
            "w": self.canvas_width,
            "h": self.canvas_height,
            "bg": self.bg,
            "mode": self.mode_name,
            "world": self.world
        })

    def clear(self):
        _emit({"type": "clear", "bg": self.bg})

screen_state = _ScreenState()

class _TurtleState:
    def __init__(self, screen):
        self.screen = screen
        self.tid = _next_turtle_id(screen)
        self.reset_state()

    def reset_state(self):
        self.x = 0.0
        self.y = 0.0
        self.heading = 0.0
        self.pen_down = True
        self.pen_color = "black"
        self.fill_color = "black"
        self.pen_size = 1
        self.fill_active = False
        self.fill_path = []
        self.speed_value = 3
        self.visible = True
        self.shape_name = "classic"
        self.resizemode_value = "noresize"
        self.stretch_wid = 1.0
        self.stretch_len = 1.0
        self.outline = 1
        self.tilt_angle = 0.0
        self.shear_factor = 0.0
        self._stamp_id = 0
        self._stamps = []
        self._undo_buffer = 0
        _emit_turtle(self)

    def copy_from(self, other):
        self.x = other.x
        self.y = other.y
        self.heading = other.heading
        self.pen_down = other.pen_down
        self.pen_color = other.pen_color
        self.fill_color = other.fill_color
        self.pen_size = other.pen_size
        self.fill_active = other.fill_active
        self.fill_path = list(other.fill_path)
        self.speed_value = other.speed_value
        self.visible = other.visible
        self.shape_name = other.shape_name
        self.resizemode_value = other.resizemode_value
        self.stretch_wid = other.stretch_wid
        self.stretch_len = other.stretch_len
        self.outline = other.outline
        self.tilt_angle = other.tilt_angle
        self.shear_factor = other.shear_factor
        self._stamp_id = other._stamp_id
        self._stamps = list(other._stamps)
        self._undo_buffer = other._undo_buffer

    def _heading_to_radians(self):
        angle = self.heading
        if self.screen.mode_name == "logo":
            angle = 90 - angle
        return math.radians(angle)

    def _angle_to_heading(self, angle):
        if self.screen.mode_name == "logo":
            return (90 - angle) % 360
        return angle % 360

    def _rotate(self, angle):
        if self.screen.mode_name == "logo":
            self.heading = (self.heading - angle) % 360
        else:
            self.heading = (self.heading + angle) % 360

    def _move(self, dist):
        radians = self._heading_to_radians()
        nx = self.x + math.cos(radians) * dist
        ny = self.y + math.sin(radians) * dist
        x1, y1 = self.x, self.y
        if self.fill_active:
            self.fill_path.append((nx, ny))
        self.x = nx
        self.y = ny
        _emit_move(self, x1, y1, nx, ny, self.pen_down)

    def forward(self, dist):
        self._move(dist)

    def fd(self, dist):
        self.forward(dist)

    def back(self, dist):
        self._move(-dist)

    def backward(self, dist):
        self.back(dist)

    def bk(self, dist):
        self.back(dist)

    def left(self, angle):
        if self.screen.mode_name == "logo":
            self.heading = (self.heading - angle) % 360
        else:
            self.heading = (self.heading + angle) % 360
        _emit_turn(self)

    def lt(self, angle):
        self.left(angle)

    def right(self, angle):
        if self.screen.mode_name == "logo":
            self.heading = (self.heading + angle) % 360
        else:
            self.heading = (self.heading - angle) % 360
        _emit_turn(self)

    def rt(self, angle):
        self.right(angle)

    def goto(self, x, y=None):
        x, y = _parse_position(x, y)
        x1, y1 = self.x, self.y
        if self.fill_active:
            self.fill_path.append((x, y))
        self.x = x
        self.y = y
        _emit_move(self, x1, y1, x, y, self.pen_down)

    def setpos(self, x, y=None):
        self.goto(x, y)

    def setposition(self, x, y=None):
        self.goto(x, y)

    def setx(self, x):
        self.goto(x, self.y)

    def sety(self, y):
        self.goto(self.x, y)

    def position(self):
        return (self.x, self.y)

    def pos(self):
        return (self.x, self.y)

    def xcor(self):
        return self.x

    def ycor(self):
        return self.y

    def towards(self, x, y=None):
        x, y = _parse_position(x, y)
        dx = x - self.x
        dy = y - self.y
        if dx == 0 and dy == 0:
            return self.heading
        angle = math.degrees(math.atan2(dy, dx))
        return self._angle_to_heading(angle)

    def distance(self, x, y=None):
        if isinstance(x, Turtle):
            x, y = x.position()
        else:
            x, y = _parse_position(x, y)
        if x is None or y is None:
            return 0.0
        return math.hypot(x - self.x, y - self.y)

    def penup(self):
        self.pen_down = False

    def pu(self):
        self.penup()

    def pendown(self):
        self.pen_down = True

    def pd(self):
        self.pendown()

    def isdown(self):
        return self.pen_down

    def pen(self, pen=None, **pendict):
        if pen is None and not pendict:
            return {
                "shown": self.visible,
                "pendown": self.pen_down,
                "pencolor": self.pen_color,
                "fillcolor": self.fill_color,
                "pensize": self.pen_size,
                "speed": self.speed_value,
                "resizemode": self.resizemode_value,
                "stretchfactor": (self.stretch_len, self.stretch_wid),
                "shearfactor": self.shear_factor,
                "outline": self.outline,
                "tilt": self.tilt_angle,
                "shape": self.shape_name
            }
        if isinstance(pen, dict):
            pendict = {**pen, **pendict}
        if "shown" in pendict:
            self.visible = bool(pendict["shown"])
        if "pendown" in pendict:
            self.pen_down = bool(pendict["pendown"])
        if "pencolor" in pendict:
            self.pencolor(pendict["pencolor"])
        if "fillcolor" in pendict:
            self.fillcolor(pendict["fillcolor"])
        if "pensize" in pendict:
            self.pensize(pendict["pensize"])
        if "speed" in pendict:
            self.speed(pendict["speed"])
        if "resizemode" in pendict:
            self.resizemode(pendict["resizemode"])
        if "stretchfactor" in pendict:
            sf = pendict["stretchfactor"]
            if isinstance(sf, (tuple, list)) and len(sf) >= 2:
                self.stretch_len = sf[0]
                self.stretch_wid = sf[1]
        if "outline" in pendict:
            self.outline = pendict["outline"]
        if "shearfactor" in pendict:
            self.shearfactor(pendict["shearfactor"])
        if "tilt" in pendict:
            self.settiltangle(pendict["tilt"])
        if "shape" in pendict:
            self.shape(pendict["shape"])

    def color(self, *args):
        if len(args) == 0:
            return (self.pen_color, self.fill_color)
        if len(args) == 1:
            color = _color_from_args(args)
            self.pen_color = _color_to_css(color, self.screen.color_mode)
            self.fill_color = _color_to_css(color, self.screen.color_mode)
        elif len(args) == 2:
            self.pen_color = _color_to_css(args[0], self.screen.color_mode)
            self.fill_color = _color_to_css(args[1], self.screen.color_mode)
        else:
            color = _color_from_args(args)
            self.pen_color = _color_to_css(color, self.screen.color_mode)
            self.fill_color = _color_to_css(color, self.screen.color_mode)
        _emit_turtle(self)
        return (self.pen_color, self.fill_color)

    def pencolor(self, *args):
        if len(args) == 0:
            return self.pen_color
        color = _color_from_args(args)
        self.pen_color = _color_to_css(color, self.screen.color_mode)
        _emit_turtle(self)
        return self.pen_color

    def fillcolor(self, *args):
        if len(args) == 0:
            return self.fill_color
        color = _color_from_args(args)
        self.fill_color = _color_to_css(color, self.screen.color_mode)
        _emit_turtle(self)
        return self.fill_color

    def pensize(self, size=None):
        if size is None:
            return self.pen_size
        self.pen_size = size
        _emit_turtle(self)

    def width(self, size=None):
        return self.pensize(size)

    def dot(self, size=None, color=None):
        if size is None:
            size = max(self.pen_size + 4, self.pen_size * 2)
        _emit({"type": "dot", "tid": self.tid, "x": self.x, "y": self.y, "size": size, "color": _color_to_css(color, self.screen.color_mode) if color else self.pen_color})

    def stamp(self):
        self._stamp_id += 1
        stamp_id = self._stamp_id
        self._stamps.append(stamp_id)
        self.dot(max(self.pen_size + 6, self.pen_size * 2), self.pen_color)
        return stamp_id

    def clearstamp(self, stampid):
        if stampid in self._stamps:
            self._stamps.remove(stampid)

    def clearstamps(self, n=None):
        if n is None:
            self._stamps = []
        elif n > 0:
            self._stamps = self._stamps[:-n]
        elif n == 0:
            return
        else:
            self._stamps = self._stamps[-n:]

    def write(self, text, move=False, align="left", font=("Arial", 8, "normal")):
        _emit({"type": "text", "tid": self.tid, "x": self.x, "y": self.y, "text": str(text), "color": self.pen_color, "font": _font_to_css(font), "align": align})

    def clear(self):
        self.screen.clear()

    def reset(self):
        self.screen._emit_init()
        self.reset_state()

    def home(self):
        self.goto(0, 0)
        self.heading = 0
        _emit_turn(self)

    def setheading(self, angle):
        self.heading = angle % 360
        _emit_turn(self)

    def seth(self, angle):
        self.setheading(angle)

    def begin_fill(self):
        self.fill_active = True
        self.fill_path = [(self.x, self.y)]
        _emit({"type": "fill_start", "tid": self.tid})

    def end_fill(self):
        if self.fill_active and len(self.fill_path) > 2:
            _emit({"type": "fill", "tid": self.tid, "points": self.fill_path, "color": self.fill_color})
        else:
            _emit({"type": "fill_end", "tid": self.tid})
        self.fill_active = False
        self.fill_path = []

    def filling(self):
        return self.fill_active

    def circle(self, radius, extent=None, steps=None):
        if extent is None:
            extent = 360
        if steps is None:
            frac = abs(extent) / 360.0
            steps = 1 + int(min(11 + abs(radius) / 6.0, 59.0) * frac)
        w = float(extent) / steps
        w2 = 0.5 * w
        l = 2.0 * radius * math.sin(math.radians(w2))
        if radius &lt; 0:
            l, w, w2 = -l, -w, -w2
        self._rotate(w2)
        for _ in range(steps):
            self._move(l)
            self._rotate(w)
        self._rotate(-w2)
        _emit_turn(self)

    def speed(self, value=None):
        if value is None:
            return self.speed_value
        self.speed_value = value

    def colormode(self, value=None):
        if value is None:
            return self.screen.color_mode
        self.screen.color_mode = value
        return self.screen.color_mode

    def hideturtle(self):
        self.visible = False
        _emit_turtle(self)

    def ht(self):
        self.hideturtle()

    def showturtle(self):
        self.visible = True
        _emit_turtle(self)

    def st(self):
        self.showturtle()

    def isvisible(self):
        return self.visible

    def shape(self, name=None):
        if name is None:
            return self.shape_name
        self.shape_name = str(name)
        self.screen.shapes.add(self.shape_name)
        _emit_turtle(self)
        return self.shape_name

    def shapesize(self, stretch_wid=None, stretch_len=None, outline=None):
        if stretch_wid is None:
            return (self.stretch_wid, self.stretch_len, self.outline)
        if stretch_len is None:
            stretch_len = stretch_wid
        self.stretch_wid = float(stretch_wid)
        self.stretch_len = float(stretch_len)
        if outline is not None:
            self.outline = outline
        _emit_turtle(self)
        return (self.stretch_wid, self.stretch_len, self.outline)

    def turtlesize(self, stretch_wid=None, stretch_len=None, outline=None):
        return self.shapesize(stretch_wid, stretch_len, outline)

    def resizemode(self, mode=None):
        if mode is None:
            return self.resizemode_value
        self.resizemode_value = mode
        return self.resizemode_value

    def settiltangle(self, angle):
        self.tilt_angle = angle % 360
        return self.tilt_angle

    def tiltangle(self, angle=None):
        if angle is None:
            return self.tilt_angle
        return self.settiltangle(angle)

    def tilt(self, angle):
        return self.settiltangle(self.tilt_angle + angle)

    def shearfactor(self, factor=None):
        if factor is None:
            return self.shear_factor
        self.shear_factor = factor
        return self.shear_factor

    def setundobuffer(self, size):
        self._undo_buffer = size

    def undobufferentries(self):
        return 0

    def undo(self):
        pass

    def getscreen(self):
        return screen

    def onclick(self, fun=None, btn=1, add=None):
        btn = _normalize_button(btn)
        _set_handler(self.screen.turtle_click_handlers, btn, fun, add)

    def ondrag(self, fun=None, btn=1, add=None):
        btn = _normalize_button(btn)
        _set_handler(self.screen.turtle_drag_handlers, btn, fun, add)

    def onrelease(self, fun=None, btn=1, add=None):
        btn = _normalize_button(btn)
        _set_handler(self.screen.turtle_release_handlers, btn, fun, add)

    def update(self):
        screen.update()

    def clone(self):
        t = Turtle()
        t._state.copy_from(self)
        return t

class Turtle:
    def __init__(self):
        self._state = _TurtleState(screen_state)

    def __getattr__(self, name):
        return getattr(self._state, name)

    def heading(self):
        return self._state.heading

class Screen:
    def __init__(self):
        self._state = screen_state

    def bgcolor(self, color=None):
        if color is None:
            return self._state.bg
        self._state.bg = _color_to_css(color, self._state.color_mode)
        self._state.clear()

    def bgpic(self, picname=None):
        if picname is None:
            return self._state.bg_picture
        self._state.bg_picture = picname
        _emit({"type": "bgpic", "name": picname})

    def setup(self, width=400, height=300, startx=None, starty=None):
        self._state.canvas_width = CANVAS_WIDTH
        self._state.canvas_height = CANVAS_HEIGHT
        self._state._emit_init()

    def screensize(self, canvwidth=None, canvheight=None, bg=None):
        if bg is not None:
            self._state.bg = _color_to_css(bg, self._state.color_mode)
        self._state.canvas_width = CANVAS_WIDTH
        self._state.canvas_height = CANVAS_HEIGHT
        self._state._emit_init()
        return (self._state.canvas_width, self._state.canvas_height)

    def window_width(self):
        return self._state.canvas_width

    def window_height(self):
        return self._state.canvas_height

    def clearscreen(self):
        self.reset()

    def reset(self):
        self._state._emit_init()
        default_turtle._state.reset_state()

    def tracer(self, n=None, delay=None):
        if n is not None:
            self._state.tracer_n = n
        if delay is not None:
            self._state.delay_ms = delay
        if n is not None and n != 0:
            self.update()

    def update(self):
        if self._state.pending_events:
            pending = list(self._state.pending_events)
            self._state.pending_events = []
            for event in pending:
                _send(event)

    def delay(self, delay=None):
        if delay is None:
            return self._state.delay_ms
        self._state.delay_ms = delay

    def title(self, text=""):
        self._state.title_text = text

    def mode(self, mode=None):
        if mode is None:
            return self._state.mode_name
        next_mode = str(mode).lower()
        if next_mode not in ["standard", "logo", "world"]:
            return self._state.mode_name
        self._state.mode_name = next_mode
        if next_mode != "world":
            self._state.world = None
        self.reset()
        return self._state.mode_name

    def colormode(self, value=None):
        if value is None:
            return self._state.color_mode
        self._state.color_mode = value
        return self._state.color_mode

    def listen(self, xdummy=None, ydummy=None):
        self._state.listen_enabled = True
        _send({"type": "listen", "enabled": True})

    def onkey(self, fun, key):
        key = _normalize_key(key)
        _set_handler(self._state.key_release_handlers, key, fun, False)

    def onkeypress(self, fun, key=None):
        key = _normalize_key(key)
        if key is None:
            _set_any_handler(self._state.key_any_press, fun, False)
        else:
            _set_handler(self._state.key_press_handlers, key, fun, False)

    def onkeyrelease(self, fun, key=None):
        key = _normalize_key(key)
        if key is None:
            _set_any_handler(self._state.key_any_release, fun, False)
        else:
            _set_handler(self._state.key_release_handlers, key, fun, False)

    def onclick(self, fun, btn=1, add=None):
        btn = _normalize_button(btn)
        _set_handler(self._state.mouse_click_handlers, btn, fun, add)

    def onscreenclick(self, fun, btn=1, add=None):
        self.onclick(fun, btn, add)

    def exitonclick(self):
        pass

    def bye(self):
        pass

    def textinput(self, title, prompt):
        return None

    def numinput(self, title, prompt, default=None, minval=None, maxval=None):
        return None

    def getcanvas(self):
        return None

    def register_shape(self, name, shape=None):
        self._state.shapes.add(name)

    def addshape(self, name, shape=None):
        self._state.shapes.add(name)

    def getshapes(self):
        return list(self._state.shapes)

    def setworldcoordinates(self, llx, lly, urx, ury):
        if self._state.mode_name != "world":
            self.mode("world")
        self._state.world = {
            "llx": float(llx),
            "lly": float(lly),
            "urx": float(urx),
            "ury": float(ury)
        }
        _emit({
            "type": "world",
            "llx": self._state.world["llx"],
            "lly": self._state.world["lly"],
            "urx": self._state.world["urx"],
            "ury": self._state.world["ury"],
            "mode": self._state.mode_name
        })

    def mainloop(self):
        pass

def _dispatch_key(event):
    if not screen_state.listen_enabled:
        return
    key = _normalize_key(event.get("key"))
    kind = event.get("kind")
    if kind == "press":
        if key is not None:
            _call_handlers(screen_state.key_press_handlers, key)
        _call_any(screen_state.key_any_press)
    elif kind == "release":
        if key is not None:
            _call_handlers(screen_state.key_release_handlers, key)
        _call_any(screen_state.key_any_release)

def _dispatch_mouse(event):
    btn = _normalize_button(event.get("button", 1))
    x = float(event.get("x", 0))
    y = float(event.get("y", 0))
    kind = event.get("kind")
    target = event.get("target", "screen")
    if kind == "click":
        _call_handlers(screen_state.mouse_click_handlers, btn, x, y)
        if target == "turtle":
            _call_handlers(screen_state.turtle_click_handlers, btn, x, y)
    elif kind == "drag":
        if target == "turtle":
            _call_handlers(screen_state.turtle_drag_handlers, btn, x, y)
    elif kind == "release":
        _call_handlers(screen_state.mouse_release_handlers, btn, x, y)
        if target == "turtle":
            _call_handlers(screen_state.turtle_release_handlers, btn, x, y)

def _handle_event(payload):
    event = payload
    if hasattr(payload, "to_py"):
        event = payload.to_py()
    if isinstance(event, str):
        try:
            event = json.loads(event)
        except Exception:
            return
    if not isinstance(event, dict):
        return
    etype = event.get("type")
    if etype == "key":
        _dispatch_key(event)
    elif etype == "mouse":
        _dispatch_mouse(event)

js.turtle_recv = create_proxy(_handle_event)

screen = Screen()

def _get_screen():
    return screen

default_turtle = Turtle()

mod = types.ModuleType("turtle")
mod.Turtle = Turtle
mod.RawTurtle = Turtle
mod.Pen = Turtle
mod.Screen = _get_screen
mod.getscreen = _get_screen
mod.forward = default_turtle.forward
mod.fd = default_turtle.fd
mod.back = default_turtle.back
mod.backward = default_turtle.backward
mod.bk = default_turtle.bk
mod.left = default_turtle.left
mod.lt = default_turtle.lt
mod.right = default_turtle.right
mod.rt = default_turtle.rt
mod.goto = default_turtle.goto
mod.setpos = default_turtle.setpos
mod.setposition = default_turtle.setposition
mod.setx = default_turtle.setx
mod.sety = default_turtle.sety
mod.position = default_turtle.position
mod.pos = default_turtle.pos
mod.xcor = default_turtle.xcor
mod.ycor = default_turtle.ycor
mod.towards = default_turtle.towards
mod.distance = default_turtle.distance
mod.penup = default_turtle.penup
mod.pu = default_turtle.pu
mod.pendown = default_turtle.pendown
mod.pd = default_turtle.pd
mod.isdown = default_turtle.isdown
mod.pen = default_turtle.pen
mod.color = default_turtle.color
mod.pencolor = default_turtle.pencolor
mod.fillcolor = default_turtle.fillcolor
mod.pensize = default_turtle.pensize
mod.width = default_turtle.width
mod.dot = default_turtle.dot
mod.stamp = default_turtle.stamp
mod.clearstamp = default_turtle.clearstamp
mod.clearstamps = default_turtle.clearstamps
mod.write = default_turtle.write
mod.clear = default_turtle.clear
mod.reset = default_turtle.reset
mod.home = default_turtle.home
mod.heading = default_turtle.heading
mod.setheading = default_turtle.setheading
mod.seth = default_turtle.seth
mod.circle = default_turtle.circle
mod.begin_fill = default_turtle.begin_fill
mod.end_fill = default_turtle.end_fill
mod.filling = default_turtle.filling
mod.speed = default_turtle.speed
mod.hideturtle = default_turtle.hideturtle
mod.ht = default_turtle.ht
mod.showturtle = default_turtle.showturtle
mod.st = default_turtle.st
mod.isvisible = default_turtle.isvisible
mod.shape = default_turtle.shape
mod.shapesize = default_turtle.shapesize
mod.turtlesize = default_turtle.turtlesize
mod.resizemode = default_turtle.resizemode
mod.settiltangle = default_turtle.settiltangle
mod.tiltangle = default_turtle.tiltangle
mod.tilt = default_turtle.tilt
mod.shearfactor = default_turtle.shearfactor
mod.setundobuffer = default_turtle.setundobuffer
mod.undobufferentries = default_turtle.undobufferentries
mod.undo = default_turtle.undo
mod.onclick = default_turtle.onclick
mod.ondrag = default_turtle.ondrag
mod.onrelease = default_turtle.onrelease
mod.clone = default_turtle.clone
mod.bgcolor = screen.bgcolor
mod.bgpic = screen.bgpic
mod.screensize = screen.screensize
mod.window_width = screen.window_width
mod.window_height = screen.window_height
mod.setup = screen.setup
mod.clearscreen = screen.clearscreen
mod.title = screen.title
mod.tracer = screen.tracer
mod.update = screen.update
mod.delay = screen.delay
mod.mode = screen.mode
mod.colormode = screen.colormode
mod.listen = screen.listen
mod.onkey = screen.onkey
mod.onkeypress = screen.onkeypress
mod.onkeyrelease = screen.onkeyrelease
mod.onscreenclick = screen.onscreenclick
mod.exitonclick = screen.exitonclick
mod.bye = screen.bye
mod.textinput = screen.textinput
mod.numinput = screen.numinput
mod.getshapes = screen.getshapes
mod.register_shape = screen.register_shape
mod.addshape = screen.addshape
mod.setworldcoordinates = screen.setworldcoordinates
mod.mainloop = screen.mainloop
mod.done = screen.mainloop

import sys
sys.modules["turtle"] = mod

`;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#applyResponsiveCardState">applyResponsiveCardState</a></li><li><a href="global.html#bindUi">bindUi</a></li><li><a href="global.html#createUuid">createUuid</a></li><li><a href="global.html#decodeUtf8Fallback">decodeUtf8Fallback</a></li><li><a href="global.html#getStoreKey">getStoreKey</a></li><li><a href="global.html#handleStdinResponse">handleStdinResponse</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initializeRuntime">initializeRuntime</a></li><li><a href="global.html#onAssetUpload">onAssetUpload</a></li><li><a href="global.html#remixSnapshot">remixSnapshot</a></li><li><a href="global.html#resetSnapshot">resetSnapshot</a></li><li><a href="global.html#router">router</a></li><li><a href="global.html#runActiveFile">runActiveFile</a></li><li><a href="global.html#runCode">runCode</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sat Feb 07 2026 16:58:04 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
